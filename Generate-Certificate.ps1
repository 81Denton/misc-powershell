<#
.SYNOPSIS
    This script/function generates requests and receives a New Certificate from your Issuing Certificate Authority.

    When used in conjunction with the Generate-CertTemplate script, almost all needs can be satisfied.

    This can be run as a script by uncommenting the very last line calling the Generate-Certificate function, or by simply loading the
    entire function into your current PowerShell shell and then calling it.

    IMPORTANT NOTE 1: By running the function without any parameters, the user will be walked through several prompts. 
    This is the recommended way to use this function until the user feels comfortable with parameters mentioned below.

.DESCRIPTION
    This function/script is split into the following sections (ctl-f to jump to each of these sections)
    - Helper Functions
    - Initial Variable Definition and Validation
    - Additional Variable Definition and Config File Creation
    - Generate Certificate Request and Submit to Issuing Certificate Authority

    OUTPUTS
    This function/script generates the following outputs to the $CertGenWorking directory specified by the user:
        - A Certificate Request Configuration File (with .inf file extension) - 
            RELEVANT PARAMETER: $CertificateRequestConfigFile
        - A Certificate Request File (with .csr file extenstion) - 
            RELEVANT PARAMETER: $CertificateRequestFile
        - A Certificate Request Response File (with .rsp file extension) 
            NOTE: This file is not explicitly generated by the script. Rather, it is received from the Issuing Certificate Authority after 
            the Certificate Request is submitted
        - A Certificate File (with .cer file extension) - 
            RELEVANT PARAMETER: $CertFileOut
            NOTE: This file is not explicitly generated by the script. Rather, it is received from the Issuing Certificate Authority after 
            the Certificate Request is submitted and accepted by the Issuing Certificate Authority. 
            NOTE: This file is a public certificate.
            NOTE: If you choose to use Win32 OpenSSL to extract certs/keys from the .pfx file (see below), this file should have the EXACT SAME CONTENT
            as the file "..._public_key_sans_chain.pem"
        - A Certificate Chain File (with .p7b file extension) -
            RELEVANT PARAMETER: $CertificateChainOut
            NOTE: This file is not explicitly generated by the script. Rather, it is received from the Issuing Certificate Authority after 
            the Certificate Request is submitted and accepted by the Issuing Certificate Authority
            NOTE: This file contains the entire chain of public certificates, from the requested certificate, up to the Root CA
            WARNING: In order to parse the public certificates for each entity up the chain, you MUST use the Crypto Shell Extensions GUI,
            otherwise, if you look at this content with a text editor, it appears as only one (1) public certificate.  Use the OpenSSL
            Certificate Chain File ($AllPublicKeysInChainOut) optional output in order to view a text file that parses each entity's public certificate.
        - A .pfx File Containing the Entire Public Certificate Chain AS WELL AS the Private Key of your New Certificate - 
            RELEVANT PARAMETER: $PFXFileOut
            NOTE: The Private Key must be marked as exportable in your Certificate Request Configuration File in order for the .pfx file to
            contain the private key. The Private Key is marked as exportable by default.
    
    OPTIONAL OUTPUTS
    If the $UseOpenSSL parameter is set to "Yes" or "y", then the following additional outputs will be created.
    WARNING: This creates a Dependency on a third party Win32 OpenSSL binary that can be found here:
    https://indy.fulgan.com/SSL/
    For more information, see the DEPENDENCIES Section below
        - A Certificate Chain File (ending with "all_public_keys_in_chain.pem") -
            RELEVANT PARAMETER: $AllPublicKeysInChainOut
            NOTE: This optional parameter differs from the aforementioned .p7b certificate chain output in that it actually parses
            each entity's public certificate in a way that is viewable in a text editor.
        - A Certificate File (ending with "public_key_sans_chain.pem") -
            RELEVANT PARAMETER: $PublicKeySansChainOutFile
            NOTE: The content of this file should be EXACTLY THE SAME as the Certificate File with file extension .cer referenced earlier.
        - A Password Protected Private Key file (ending with "protected_private_key.pem") -
            RELEVANT PARAMETER: $ProtectedPrivateKeyOut
            NOTE: This is the New Certificate's Private Key that is protected by a password.
        - If $StripPrivateKeyOfPassword is set to "Yes" or "y", then an Unprotected Private Key File will be generated (ends with unprotected_private_key.key) -
            RELEVANT PARAMETER: $UnProtectedPrivateKeyOut

.DEPENDENCIES
    OPTIONAL DEPENDENCIES
    If the $UseOpenSSL parameter is set to "Yes" or "y", the script/function depends on the latest Win32 OpenSSL binary that can be found here:
    https://indy.fulgan.com/SSL/
    
    Simply extract the (32-bit) zip and place the directory on your filesystem in a location to be referenced by the parameter $PathToWin32OpenSSL.

    IMPORTANT NOTE 2: The above third-party Win32 OpenSSL binary is referenced by OpenSSL.org here:
    https://wiki.openssl.org/index.php/Binaries

.SAMPLE USAGE
    Without any parameters, this script/function will walk you through everything with a series of questions:
    Generate-Certificate

    For automation, pass parameters in via the command line:
    Generate-Certificate -CertGenWorking "C:\Users\zeroadmin\Desktop\CertGenWorking" -BasisTemplate "CertTempl15" -CertificateCN "LuigiCert" `
    -PFXPwdAsSecureString "ThisIsNotSecure321!" -Organization "Contoso Inc" -OrganizationalUnit "IT" -Locality "Portland" -State "OR" -Country "US" `
    -MachineKeySet "FALSE" -SecureEmail "No" -UserProtected "No" -ProviderNameOverride "No" -RequestTypeOverride "No" -UseOpenSSL "Yes" `
    -PathToWin32OpenSSL "C:\openssl-0.9.8r-i386-win32-rev2" -StripPrivateKeyOfPassword "Yes"

    IMPORTANT NOTE 3: While all parameters as they are defined below are technically not Mandatory (i.e. Mandatory=$False), those parameters with
    a default definition including "Read-Host -Prompt" are effectively Mandatory since the script/function will ask you for inputs if they are
    not specified in the command line. In order to use for automation, these "Effectively Mandatory Parameters" need to be defined in the command line.
    Parameters that are "Effectively Mandatory" are:
    - $CertGenWorking
    - $BasisTemplate
    - $CertificateCN
    - $PFXPwdAsSecureString
    - $Organization
    - $OrganizationalUnit
    - $Locality
    - $State
    - $Country
    - $MachineKeySet
    - $SecureEmail
    - $UserProtected
    - $UseOpenSSL

    IMPORTANT NOTE 4: All variables/parameters with the term "Override" in them speak to overriding attributes inheritted from the $BasisTemplate.
    If you want to receive an *interactive* walkthrough to set a specific value, set the corresponding "Override" parameter to "Yes" or "y". For example,
    if you think you want to override the ProviderName in the $BasisTemplate, but are unsure exactly what to set it to, set the 
    $ProviderNameOverride parameter to "Yes" or "y" to receive an interactive walkthrough:

    Generate-Certificate -CertGenWorking "C:\Users\zeroadmin\Desktop\CertGenWorking" -BasisTemplate "CertTempl15" -CertificateCN "LionCert" `
    -Organization "Contoso Inc" -OrganizationalUnit "IT" -Locality "Portland" -State "OR" -Country "US" -MachineKeySet "FALSE" `
    -SecureEmail "No" -UserProtected "No" -ProviderNameOverride "Yes" -RequestTypeOverride "No" -UseOpenSSL "Yes" `
    -PathToWin32OpenSSL "C:\openssl-0.9.8r-i386-win32-rev2" -StripPrivateKeyOfPassword "Yes"

    If you already know what you want to set the ProviderName to and you do NOT need an interactive walkthrough, simply use the 
    $ProviderNameValue parameter:

    Generate-Certificate -CertGenWorking "C:\Users\zeroadmin\Desktop\CertGenWorking" -BasisTemplate "CertTempl15" -CertificateCN "LionCert" `
    -Organization "Contoso Inc" -OrganizationalUnit "IT" -Locality "Portland" -State "OR" -Country "US" -MachineKeySet "FALSE" `
    -SecureEmail "No" -UserProtected "No" -ProviderNameValue "Microsoft RSA SChannel Cryptographic Provider" -RequestTypeOverride "No" -UseOpenSSL "Yes" `
    -PathToWin32OpenSSL "C:\openssl-0.9.8r-i386-win32-rev2" -StripPrivateKeyOfPassword "Yes"


#>

Function Generate-Certificate {
[CmdletBinding()]
Param(
    [Parameter(Mandatory=$False)]
    $CertGenWorking = $(Read-Host -Prompt "Please enter a full path to a directory that the New Certificate will be saved to"),

    [Parameter(Mandatory=$False)]
    $BasisTemplate = $(Read-Host -Prompt "Please enter the name of an existing Certificate Template that you would like your New Certificate Template
    to be based on"),

    [Parameter(Mandatory=$False)]
    $CertificateCN = $(Read-Host -Prompt "Please enter the Name that you would like your Certificate to have
    For a Computer/Client/Server Certificate, recommend using host FQDN)"),

    [Parameter(Mandatory=$False)]
    $CertificateRequestConfigFile = "NewCertRequestConfig_$CertificateCN"+$(Get-Date -format 'dd-MMM-yyyy_HHmm')+".inf",

    [Parameter(Mandatory=$False)]
    $CertificateRequestFile = "NewCertRequest_$CertificateCN"+$(Get-Date -format 'dd-MMM-yyyy_HHmm')+".csr",

    [Parameter(Mandatory=$False)]
    $CertFileOut = "NewCertificate_$CertificateCN"+$(Get-Date -format 'dd-MMM-yyyy_HHmm')+".cer",

    [Parameter(Mandatory=$False)]
    $CertificateChainOut = "NewCertificateChain_$CertificateCN"+$(Get-Date -format 'dd-MMM-yyyy_HHmm')+".p7b",

    [Parameter(Mandatory=$False)]
    $PFXFileOut = "NewCertificate_$CertificateCN"+$(Get-Date -format 'dd-MMM-yyyy_HHmm')+".pfx",

    [Parameter(Mandatory=$False)]
    $PFXPwdAsSecureString = $(Read-Host -Prompt "Please enter a password to use when exporting .pfx bundle certificate/key bundle" -AsSecureString),

    # WE can determine this automatically with certutil
    #[Parameter(Mandatory=$False)]
    #$IssuingCertAuthFQDN = $(Read-Host -Prompt "Please enter the FQDN the server responsible for Issuing New Certificates.
    #NOTE: The servername must be able to be resolved via DNS"),

    [Parameter(Mandatory=$False)]
    $Organization = $(Read-Host -Prompt "Please enter the name of the the Company that will appear on the New Certificate"),

    [Parameter(Mandatory=$False)]
    $OrganizationalUnit = $(Read-Host -Prompt "Please enter the name of the Department that you work for within your Company"),

    [Parameter(Mandatory=$False)]
    $Locality = $(Read-Host -Prompt "Please enter the City where your Company is located"),

    [Parameter(Mandatory=$False)]
    $State = $(Read-Host -Prompt "Please enter the State where your Company is located"),

    [Parameter(Mandatory=$False)]
    $Country = $(Read-Host -Prompt "Please enter the Country where your Company is located"),

    <#
    # ValidityPeriod is controlled by the Certificate Template and cannot be modified at the time of certificate request
    # (Unless it is a special circumstance where "RequestType = Cert" resulting in a self-signed cert where no request
    # is actually submitted)
    [Parameter(Mandatory=$False)]
    $ValidityPeriodValue = $(Read-Host -Prompt "Please enter the length of time that the certificate will be valid for.
    NOTE: Values must be in Months or Years. For example '6 months' or '2 years'"),
    #>

    [Parameter(Mandatory=$False)]
    $KeyLengthOverride = "No",

    [Parameter(Mandatory=$False)]
    $KeyLength = "2048",

    [Parameter(Mandatory=$False)]
    $HashAlgorithmOverride = "No",

    [Parameter(Mandatory=$False)]
    $HashAlgorithmValue = "sha256",

    <#
    # KeyAlgorithm should be determined by ProviderName. Run "certutil -csplist" to see which Providers use which Key Algorithms
    [Parameter(Mandatory=$False)]
    $KeyAlgorithmOverride = "No",

    [Parameter(Mandatory=$False)]
    $KeyAlgorithmValue,
    #>

    [Parameter(Mandatory=$False)]
    $EncryptionAlgorithmOverride = "No",

    [Parameter(Mandatory=$False)]
    $EncryptionAlgorithmValue = "AES",

    [Parameter(Mandatory=$False)]
    $PrivateKeyExportableOverride = "No",

    [Parameter(Mandatory=$False)]
    $PrivateKeyExportableValue = "TRUE",

    [Parameter(Mandatory=$False)]
    $KeySpecOverride = "No",

    [Parameter(Mandatory=$False)]
    $KeySpecValue = "1",

    [Parameter(Mandatory=$False)]
    $KeyUsageOverride = "No",

    [Parameter(Mandatory=$False)]
    $KeyUsageValue = "0xa0",
    
    [Parameter(Mandatory=$False)]
    $MachineKeySet = $(Read-Host -Prompt "Please enter TRUE if you are using this certificate for a service that runs in the Computer's
    security context (such as a Web Server, Domain Controller, etc). Enter FALSE for User security context [TRUE/FALSE]"),

    [Parameter(Mandatory=$False)]
    $SecureEmail = $(Read-Host -Prompt "Are you using this new certificate for Secure E-Mail? [Yes/No]"),

    [Parameter(Mandatory=$False)]
    $UserProtected = $(Read-Host -Prompt "Would you like to password protect the keys on this certificate?
    WARNING: Password protecting the keys on this certificate will force the user to enter the 
    password *every time* the certificate is accessed [Yes/No]"),

    [Parameter(Mandatory=$False)]
    $ProviderNameOverride = "No",

    [Parameter(Mandatory=$False)]
    $ProviderNameValue = "`"Microsoft RSA SChannel Cryptographic Provider`"",

    [Parameter(Mandatory=$False)]
    $RequestTypeOverride = "No",

    [Parameter(Mandatory=$False)]
    $RequestTypeValue = "PKCS10",

    [Parameter(Mandatory=$False)]
    $UseOpenSSL = $(Read-Host -Prompt "Would you like to use Win32 OpenSSL to extract public cert and private key from the Microsoft .pfx file? [Yes/No]"),

    [Parameter(Mandatory=$False)]
    $PathToWin32OpenSSL = "C:\openssl-0.9.8r-i386-win32-rev2",

    [Parameter(Mandatory=$False)]
    $AllPublicKeysInChainOut = "NewCertificate_$CertificateCN"+"_all_public_keys_in_chain_"+".pem",

    [Parameter(Mandatory=$False)]
    $PublicKeySansChainOutFile = "NewCertificate_$CertificateCN"+"_public_key_sans_chain"+".pem",

    [Parameter(Mandatory=$False)]
    $ProtectedPrivateKeyOut = "NewCertificate_$CertificateCN"+"_protected_private_key_"+".pem",
    
    [Parameter(Mandatory=$False)]
    $UnProtectedPrivateKeyOut = "NewCertificate_$CertificateCN"+"_unprotected_private_key_"+".key",

    [Parameter(Mandatory=$False)]
    $StripPrivateKeyOfPassword = "No"
)

##### BEGIN Helper Functions #####

function Convert-HexToDec {
    param($hex)

    ForEach ($value in $hex) {
        [Convert]::ToInt32($value,16)
    }
}

function Convert-DecToHex {
    param($dec)

    ForEach ($value in $dec) {
        “{0:x}” -f [Int]$value
    }
}

function Get-PermutationsAll {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$False)]
        $array,

        [Parameter(Mandatory=$False)]
        $cur = "",

        [Parameter(Mandatory=$False)]
        $depth = 0,

        [Parameter(Mandatory=$False)]
        $list = @()
    )

    $depth ++
    for ($i = 0; $i -lt $array.Count; $i++)
    {
        $list += $cur+" "+$array[$i]        

        if ($depth -lt $array.Count)
        {
            $list = Get-PermutationsAll $array ($cur+" "+$array[$i]) $depth $list
        }       
    }

    $list

}

function Get-PermutationsNoRepeats {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$False)]
        $array2,

        [Parameter(Mandatory=$False)]
        $cur2 = "",

        [Parameter(Mandatory=$False)]
        $depth2 = 0,

        [Parameter(Mandatory=$False)]
        $list2 = @()
    )

    $list2 = Get-PermutationsAll -array $array2 -cur $cur2 -depth $depth2 -list $list2

    $list3 = foreach ($obj1 in $list2) {
        [string]$obj2 = $obj1.Split(" ") | Sort-Object | Get-Unique
        $obj2
    }

    $list3 | Sort-Object | Get-Unique
}


function Get-HexArraySumPossibilities {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$False)]
        [array]$hexarray
    )

    # TODO: Validate $hexarray is values are separated by commas

    #$hexarray

    # Temporarily convert Hex to Decimal
    $hexarrayToDec = foreach ($obj1 in $hexarray) {
        Convert-HexToDec $obj1
    }
    #$hexarrayToDec

    $hexarrayToDecCombos = Get-PermutationsNoRepeats $hexarrayToDec
    [array]$hexarrayToDecCombosArray = ($hexarrayToDecCombos | %{$_.trim()}) -replace ' ',','
    #[array]$hexarrayToDecCombosArray
    

    $hexarrayDecCombosSummed = foreach ($obj1 in $hexarrayToDecCombosArray) {
        $obj2 = $obj1.Split(",")
        ($obj2 | Measure-Object -Sum).Sum
    }
    #$hexarrayDecCombosSummed

    $possibleHexSums = foreach ($obj1 in $hexarrayDecCombosSummed) {
        Convert-DecToHex $obj1
    }
    $possibleHexSums
}

##### END Helper Functions #####

##### BEGIN Initial Variable Definition and Validation #####
$DomainPrefix = ((gwmi Win32_ComputerSystem).Domain).Split(".") | Select-Object -Index 0
$DomainSuffix = ((gwmi Win32_ComputerSystem).Domain).Split(".") | Select-Object -Index 1
$Hostname = (gwmi Win32_ComputerSystem).Name
$HostFQDN = $Hostname+'.'+$DomainPrefix+'.'+$DomainSuffix
# Make sure $PFXPwdAsSecureString is a SecureString. If not, convert it to a SecureString
if ($PFXPwdAsSecureString.GetType().Name -eq "String") {
    $PFXPwdAsSecureString = ConvertTo-SecureString -String $PFXPwdAsSecureString -Force –AsPlainText
}
$AvailableCertificateAuthorities = (((certutil | Select-String -Pattern "Config:") -replace "Config:[\s]{1,32}``") -replace "'","").trim()
$IssuingCertAuth = foreach ($obj1 in $AvailableCertificateAuthorities) {
    $obj2 = certutil -config $obj1 -CAInfo type | Select-String -Pattern "Enterprise Subordinate CA" | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
    if ($obj2 -eq "Enterprise Subordinate CA") {
        $obj1
    }
}
$IssuingCertAuthFQDN = $IssuingCertAuth.Split("\") | Select-Object -Index 0
$IssuingCertAuthHostname = $IssuingCertAuth.Split("\") | Select-Object -Index 1
certutil -config $IssuingCertAuth -ping
if ($LASTEXITCODE -eq 0) {
    Write-Host "Successfully contacted the server acting as the Issuing Certificate Authority"
}
else {
    Write-Host "Cannot contact the Issuing Certificate Authority. Halting!"
    exit
}
$LDAPSearchBase = "CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,DC=$DomainPrefix,DC=$DomainSuffix"
# $AllAvailableCertificateTemplates Using PSPKI
# $AllAvailableCertificateTemplates = Get-PSPKICertificateTemplate
# Using certutil
$AllAvailableCertificateTemplatesPrep = certutil -ADTemplate
# Determine valid CN using PSPKI
# $ValidCertificateTemplatesByCN = $AllAvailableCertificateTemplatesPrep.Name
# Determine valid displayNames using certutil
$ValidCertificateTemplatesByCN = foreach ($obj1 in $AllAvailableCertificateTemplatesPrep) {
    $obj2 = $obj1 | Select-String -Pattern "[\w]{1,32}:[\s][\w]" | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
    $obj3 = $obj2 -replace ':[\s][\w]',''
    $obj3
}
$ValidCNNamesAsStringPrep = foreach ($obj1 in $ValidCertificateTemplatesByCN) {
    $obj1.Trim()+','
}
$ValidCNNamesAsString = [string]$ValidCNNamesAsStringPrep

# Determine valid displayNames using PSPKI
# $ValidCertificateTemplatesByDisplayName = $AllAvailableCertificateTemplatesPrep.DisplayName
# Determine valid displayNames using certutil
$ValidCertificateTemplatesByDisplayName = foreach ($obj1 in $AllAvailableCertificateTemplatesPrep) {
    $obj2 = $obj1 | Select-String -Pattern "\:(.*)\-\-" | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
    $obj3 = ($obj2 -replace ": ","") -replace " --",""
    $obj3
}
$ValidDisplayNamesAsStringPrep = foreach ($obj1 in $ValidCertificateTemplatesByDisplayName) {
    $obj1.Trim()+','
}
$ValidDisplayNamesAsString = [string]$ValidDisplayNamesAsStringPrep

# Set displayName and CN Values for user-provided $BasisTemplate
if ($ValidCertificateTemplatesByCN -contains $BasisTemplate) {
    $cnForBasisTemplate = $BasisTemplate
}
if ($ValidCertificateTemplatesByDisplayName -contains $BasisTemplate) {
    $displayNameForBasisTemplate = $BasisTemplate
}

if ($cnForBasisTemplate -eq $null -and $displayNameForBasisTemplate -ne $null) {
    $cnForBasisTemplatePrep1 = $AllAvailableCertificateTemplatesPrep | Select-String -Pattern $displayNameForBasisTemplate | Select-Object -ExpandProperty Line
    $cnForBasisTemplatePrep2 = $cnForBasisTemplatePrep1 | Select-String -Pattern "[\w]{1,32}:[\s][\w]" | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
    $cnForBasisTemplate = $cnForBasisTemplatePrep2 -replace ':[\s][\w]',''
}
if ($cnForBasisTemplate -ne $null -and $displayNameForBasisTemplate -eq $null) {
    $displayNameForBasisTemplatePrep1 = $AllAvailableCertificateTemplatesPrep | Select-String -Pattern $cnForBasisTemplate | Select-Object -ExpandProperty Line
    $displayNameForBasisTemplatePrep2 = $displayNameForBasisTemplatePrep1 | Select-String -Pattern "\:(.*)\-\-" | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
    $displayNameForBasisTemplate = ($displayNameForBasisTemplatePrep2 -replace ": ","") -replace " --",""
}

# ---------

if ($ValidCertificateTemplatesByCN -notcontains $BasisTemplate -and $ValidCertificateTemplatesByDisplayName -notcontains $BasisTemplate) {
    Write-Host ""
    Write-Host ""
    Write-Host "You must base your New Certificate Template on an existing Certificate Template."
    Write-Host "To do so, please enter either the displayName or CN of the Certificate Template you would like to use as your base."
    Write-Host ""
    Write-Host "Valid displayName values are as follows:"
    Write-Host ""
    $ValidDisplayNamesAsString
    Write-Host ""
    Sleep 2
    Write-Host "Valid CN values are as follows:"
    Write-Host""
    $ValidCNNamesAsString
    Write-Host""

    $BasisTemplate = Read-Host -Prompt "Please enter the displayName or CN of the Certificate Template you would like to use as your base"
    # Set displayName and CN Values for user-provided $BasisTemplate
    if ($ValidCertificateTemplatesByCN -contains $BasisTemplate) {
        $cnForBasisTemplate = $BasisTemplate
    }
    if ($ValidCertificateTemplatesByDisplayName -contains $BasisTemplate) {
        $displayNameForBasisTemplate = $BasisTemplate
    }
    if ($ValidCertificateTemplatesByCN -notcontains $BasisTemplate -and $ValidCertificateTemplatesByDisplayName -notcontains $BasisTemplate) {
        Write-Host ""
        Write-Host ""
        Write-Host "You must base your New Certificate Template on an existing Certificate Template."
        Write-Host "To do so, please enter either the displayName or CN of the Certificate Template you would like to use as your base. Halting!"
    }
}

# Make a working Directory Where Genrated Certificates will be Saved
if (Test-Path $CertGenWorking) {
    Write-Host "The working directory $CertGenWorking already exists. No action necessary."
}
else {
    mkdir $CertGenWorking
}

<#
if ($ValidityPeriodValue -match "[0-9][\s]month" -or $ValidityPeriodValue -match "[0-9][\s]months" -or $ValidityPeriodValue -match "[0-9][\s]year" -or $ValidityPeriodValue -match "[0-9][\s]years") {
    Write-Host "The value for ValidityPeriodValue is valid...continuing"
}
else {
    Write-Host "The value for ValidityPeriodValue is not valid. Please use a Validity Period in Months or Years such as '6 months' or '2 years'. Halting!"
    exit
}
#>

if ($KeyLengthOverride -eq "Yes" -or $KeyLengthOverride -eq "y" -or $KeyLengthOverride -eq "No" -or $KeyLengthOverride -eq "n") {
    Write-Host "The value for KeyLengthOverride is valid...continuing"
}
else {
    Write-Host "The value for KeyLengthOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    exit
}

if ($HashAlgorithmOverride -eq "Yes" -or $HashAlgorithmOverride -eq "y" -or $HashAlgorithmOverride -eq "No" -or $HashAlgorithmOverride -eq "n") {
    Write-Host "The value for HashAlgorithmOverride is valid...continuing"
}
else {
    Write-Host "The value for HashAlgorithmOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    exit
}

<#
# KeyAlgorithm should be determined by ProviderName. Run "certutil -csplist" to see which Providers use which Key Algorithms
if ($KeyAlgorithmOverride -eq "Yes" -or $KeyAlgorithmOverride -eq "y" -or $KeyAlgorithmOverride -eq "No" -or $KeyAlgorithmOverride -eq "n") {
    Write-Host "The value for KeyAlgorithmOverride is valid...continuing"
}
else {
    Write-Host "The value for KeyAlgorithmOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    exit
}
#>

if ($EncryptionAlgorithmOverride -eq "Yes" -or $EncryptionAlgorithmOverride -eq "y" -or $EncryptionAlgorithmOverride -eq "No" -or $EncryptionAlgorithmOverride -eq "n") {
    Write-Host "The value for EncryptionAlgorithmOverride is valid...continuing"
}
else {
    Write-Host "The value for EncryptionAlgorithmOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    exit
}

if ($PrivateKeyExportableOverride -eq "Yes" -or $PrivateKeyExportableOverride -eq "y" -or $PrivateKeyExportableOverride -eq "No" -or $PrivateKeyExportableOverride -eq "n") {
    Write-Host "The value for PrivateKeyExportableOverride is valid...continuing"
}
else {
    Write-Host "The value for PrivateKeyExportableOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    exit
}

if ($KeySpecOverride -eq "Yes" -or $KeySpecOverride -eq "y" -or $KeySpecOverride -eq "No" -or $KeySpecOverride -eq "n") {
    Write-Host "The value for KeySpecOverride is valid...continuing"
}
else {
    Write-Host "The value for KeySpecOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    exit
}

if ($KeyUsageOverride -eq "Yes" -or $KeyUsageOverride -eq "y" -or $KeyUsageOverride -eq "No" -or $KeyUsageOverride -eq "n") {
    Write-Host "The value for KeyUsageOverride is valid...continuing"
}
else {
    Write-Host "The value for KeyUsageOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    exit
}

if ($MachineKeySet -eq "TRUE" -or $MachineKeySet -eq "FALSE") {
    Write-Host "The value for MachineKeySet is valid...continuing"
}
else {
    Write-Host "The value for MachineKeySet is not valid. Please use either 'TRUE', 'FALSE'. Halting!"
    exit
}

if ($SecureEmail -eq "Yes" -or $SecureEmail -eq "y" -or $SecureEmail -eq "No" -or $SecureEmail -eq "n") {
    Write-Host "The value for SecureEmail is valid...continuing"
}
else {
    Write-Host "The value for SecureEmail is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    exit
}

if ($UserProtected -eq "Yes" -or $UserProtected -eq "y" -or $UserProtected -eq "No" -or $UserProtected -eq "n") {
    Write-Host "The value for UserProtected is valid...continuing"
}
else {
    Write-Host "The value for UserProtected is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    exit
}

if ($ProviderNameOverride -eq "Yes" -or $ProviderNameOverride -eq "y" -or $ProviderNameOverride -eq "No" -or $ProviderNameOverride -eq "n") {
    Write-Host "The value for ProviderNameOverride is valid...continuing"
}
else {
    Write-Host "The value for ProviderNameOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    exit
}

if ($RequestTypeOverride -eq "Yes" -or $RequestTypeOverride -eq "y" -or $RequestTypeOverride -eq "No" -or $RequestTypeOverride -eq "n") {
    Write-Host "The value for RequestTypeOverride is valid...continuing"
}
else {
    Write-Host "The value for RequestTypeOverride is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    exit
}

if ($UseOpenSSL -eq "Yes" -or $UseOpenSSL -eq "y" -or $UseOpenSSL -eq "No" -or $UseOpenSSL -eq "n") {
    Write-Host "The value for UseOpenSSL is valid...continuing"
}
else {
    Write-Host "The value for UseOpenSSL is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
    exit
}
##### END Initial Variable Definition and Validation #####

##### BEGIN Additional Variable Definition and Config File Creation #####
$CertificateTemplateLDAPObject = "CN=$cnForBasisTemplate,CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,DC=$DomainPrefix,DC=$DomainSuffix"
$AllCertificateTemplateProperties = Get-ADObject $CertificateTemplateLDAPObject -Properties *

Write-Host "Writing all attributes of Certificate Template that this New Certificate is Based On for user awareness/reference"
Sleep 2
$AllCertificateTemplateProperties
Sleep 2

## Start Writing Config File ##
# This content is saved to $CertGenWorking\$CertificateRequestConfigFile
# For more information about the contents of the config file, see: https://technet.microsoft.com/en-us/library/cc736326(v=ws.10).aspx
# and: 

Set-Content -Value '[Version]' -Path "$CertGenWorking\$CertificateRequestConfigFile"
Add-Content -Value 'Signature="$Windows NT$"' -Path "$CertGenWorking\$CertificateRequestConfigFile"
Add-Content -Value "`n`r" -Path "$CertGenWorking\$CertificateRequestConfigFile"
Add-Content -Value '[NewRequest]' -Path "$CertGenWorking\$CertificateRequestConfigFile"
Add-Content -Value "FriendlyName = $CertificateCN" -Path "$CertGenWorking\$CertificateRequestConfigFile"

# For below Subject, for a wildcard use "CN=*.DOMAIN.COM"
Add-Content -Value "Subject = `"CN=$CertificateCN,OU=$OrganizationalUnit,O=$Organization,L=$Locality,S=$State,C=$Country`"" -Path $CertGenWorking\$CertificateRequestConfigFile
if ($KeyLengthOverride -eq "Yes" -or $KeyLengthOverride -eq "y") {
    # Common key sizes: 512, 1024, 2048, 4096, 8192, 16384. Default is 2048
    Write-Host "Common key sizes are: 512, 1024, 2048, 4096, 8192, 16384"
    $KeyLength = Read-Host -Prompt "Please enter the KeyLength value you would like to use"
    Add-Content -Value "KeyLength = $KeyLength" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
else {
    Add-Content -Value "KeyLength = $KeyLength" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
if ($HashAlgorithmOverride -eq "Yes" -or $HashAlgorithmOverride -eq "y") {
    Write-Host ""
    Write-Host "Valid HashAlgorithm values are as follows"
    Write-Host ""
    [array]$ValidHashAlgorithmValues = (certutil -oid 1 | Select-String  pwszCNGAlgid) -replace "pwszCNGAlgid = ",""
    $ValidHashAlgorithmValues

    $HashAlgorithmValue = Read-Host -Prompt "Please enter the HashAlgorithm that you would like to use"
    Add-Content -Value "HashAlgorithm = $HashAlgorithmValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
else {
    Add-Content -Value "HashAlgorithm = $HashAlgorithmValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
<#
# # KeyAlgorithm should be determined by ProviderName. Run "certutil -csplist" to see which Providers use which Key Algorithms
if ($KeyAlgorithmOverride -eq "Yes" -or $KeyAlgorithmOverride -eq "y") {
    Write-Host ""
    Write-Host "Valid KeyAlgorithm values are as follows"
    Write-Host ""
    $ValidKeyAlgorithmValues = @("RSA","DH","DSA","ECDH_P256","ECDH_P521","ECDSA_P256","ECDSA_P384","ECDSA_P521")
    $ValidKeyAlgorithmValues

    $KeyAlgorithmValue = Read-Host -Prompt "Please enter the KeyAlgorithm that you would like to use"
    Add-Content -Value "KeyAlgorithm = $KeyAlgorithmValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
else {
    if ($KeyAlgorithmValue -ne $null) {
        Add-Content -Value "KeyAlgorithm = $KeyAlgorithmValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
    else {
        $KeyAlgorithmValue = "RSA"
        Add-Content -Value "KeyAlgorithm = $KeyAlgorithmValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
}
#>
if ($EncryptionAlgorithmOverride -eq "Yes" -or $EncryptionAlgorithmOverride -eq "y") {
    Write-Host ""
    Write-Host "Valid EncryptionAlgorithm values are as follows"
    Write-Host ""
    [array]$ValidEncryptionAlgorithmValues = (certutil -oid 2 | Select-String  pwszCNGAlgid) -replace "pwszCNGAlgid = ",""
    $ValidHashAlgorithmValues

    $EncryptionAlgorithmValue = Read-Host -Prompt "Please enter the HashAlgorithm that you would like to use"
    Add-Content -Value "EncryptionAlgorithm = $EncryptionAlgorithmValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
else {
    Add-Content -Value "EncryptionAlgorithm = $EncryptionAlgorithmValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
if ($PrivateKeyExportableOverride -eq "Yes" -or $PrivateKeyExportableOverride -eq "y") {
    $PrivKeyBool = Read-Host -Prompt "Would you like the private key to be exportable? [Yes/No]"
    # Validation check...
    if ($PrivKeyBool -eq "Yes" -or $PrivKeyBool -eq "y" -or $PrivKeyBool -eq "No" -or $PrivKeyBool -eq "n") {
        Write-Host "Value for PrivKeyBool Yes/No is valid...Continuing..."
    }
    else {
        Write-Host "The value for PrivKeyBool is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
        exit
    }
    if ($PrivKeyBool -eq "Yes" -or $PrivKeyBool -eq "y") {
        $PrivateKeyExportableValue = "TRUE"
        # Private key is exportable TRUE/FALSE
        Add-Content -Value "Exportable = $PrivateKeyExportableValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
    if ($PrivKeyBool -eq "No" -or $PrivKeyBool -eq "n") {
        $PrivateKeyExportableValue = "FALSE"
        # Private key is exportable TRUE/FALSE
        Add-Content -Value "Exportable = $PrivateKeyExportableValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
}
else {
    Add-Content -Value "Exportable = $PrivateKeyExportableValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
if ($KeySpecOverride -eq "Yes" -or $KeySpecOverride -eq "y") {
    $KeySpecValue = Read-Host -Prompt "Please enter the KeySpec value you would like to use.
    Valid values are '1' for AT_KEYEXCHANGE and '2' for AT_SIGNATURE [1,2]"
    # Validation check...
    if ($KeySpecValue -ne "1" -and $KeySpecValue -ne "2") {
        Write-Host "The value for PrivKeyBool is not valid. Please enter either 'TRUE' or 'FALSE'. Halting!"
        exit
    }
    else {
        # AT_KEYEXCHANGE which is KeySpec = 1 vs AT_SIGNATURE which is KeySpec = 2. 
        # Default is AT_KEYEXCHANGE which allows keys to be used for symmetric encryption or signing or both. Change only if you know what you're doing.
        Add-Content -Value "KeySpec = $KeySpecValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
}
else {
    Add-Content -Value "KeySpec = $KeySpecValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
if ($KeyUsageOverride -eq "Yes" -or $KeyUsageOverride -eq "y") {
    $KeyUsageHexValue = Read-Host -Prompt "Please enter the KeyUsage hexadecimal value you would like to use.

    Valid choices are one or more of the following. For multiple choices, add the hexadecimal values:
    CERT_DIGITAL_SIGNATURE_KEY_USAGE = 0x80; CERT_NON_REPUDIATION_KEY_USAGE 0x40; CERT_KEY_ENCIPHERMENT_KEY_USAGE 0x20;
    CERT_DATA_ENCIPHERMENT_KEY_USAGE 0x10; CERT_KEY_AGREEMENT_KEY_USAGE 0x08; CERT_KEY_CERT_SIGN_KEY_USAGE 0x04; 
    CERT_OFFLINE_CRL_SIGN_KEY_USAGE 0x02; CERT_CRL_SIGN_KEY_USAGE 0x02; CERT_ENCIPHER_ONLY_KEY_USAGE 0x01; 
    For AT_KEYEXCHANGE, EncipherOnly = TRUE: 0x30; For AT_KEYEXCHANGE, EncipherOnly = FALSE: 0xf0; For AT_SIGNATURE (default) 0xC0

    NOTE: The most commonly used values are 0xc0 and 0xa0 and 0xf0"

    # Validation check...
    $ValidHexValuesPrep = @(80,40,20,10,8,4,2,1)
    $ValidHexValues = Get-HexArraySumPossibilities $ValidHexValuesPrep
    # If hex values provided by user to $KeyUsagehexValue are not valid, halt script 
    if ($ValidHexValues -notcontains $KeyUsageHexValue) {
        Write-Host "$($KeyUsageHexValue) is not a valid hexadecimal value for KeyUsage. Please use 80,40,20,10,8,4,2,1, or any sum of the aforementioned. Halting!"
        exit
    }
    else {
        $KeyUsageValue = '0x'+$KeyUsageHexValue  
        Add-Content -Value "KeyUsage = $KeyUsageValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
}
else {
    Add-Content -Value "KeyUsage = $KeyUsageValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}

# MachineKeySet = TRUE/FALSE. You must set this key to TRUE if you are creating requests for domain controllers,
# a Web server, or any other service that runs in the Computer’s security context (as opposed to a User security context).
Add-Content -Value "MachineKeySet = $MachineKeySet" -Path "$CertGenWorking\$CertificateRequestConfigFile"

if ($SecureEmail -eq "Yes" -or $SecureEmail -eq "y") {
    Write-Host ""
    Write-Host "Setting KeySpec = 2 and SMIME = TRUE"
    Write-Host ""
    $KeySpecValue = 2
    $SMIMEValue = "TRUE"
    # SMIME = TRUE/FALSE. If TRUE, certificate can be used for Secure E-mail.  If KeySpec = 1, then SMIME MUST be FALSE.
    Add-Content -Value "SMIME = $SMIMEValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    (Get-Content "$CertGenWorking\$CertificateRequestConfigFile" | Foreach-Object {$_ -replace '^KeySpec =.+$', "KeySpec = $KeySpecValue"}) | Set-Content "$CertGenWorking\$CertificateRequestConfigFile"
}
else {
    if ($SMIMEValue -ne $null) {
        Add-Content -Value "SMIME = $SMIMEValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
    else {
        $SMIMEValue = "FALSE"
        # SMIME = TRUE/FALSE. If TRUE, certificate can be used for Secure E-mail.  If KeySpec = 1, then SMIME MUST be FALSE
        Add-Content -Value "SMIME = $SMIMEValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
}

Add-Content -Value 'PrivateKeyArchive = FALSE' -Path "$CertGenWorking\$CertificateRequestConfigFile"

if ($UserProtected -eq "Yes" -or $UserProtected -eq "y") {
    Write-Host ""
    Write-Host "Setting UserProtected = TRUE and MachineKeySet = FALSE"
    Write-Host ""
    $UserProtectedValue = "TRUE"
    $MachineKeySet = "FALSE"
    # If UserProtected = TRUE, the key is protected with a password, and you must enter this password every time the key is accessed
    # If using the certificate under Computer security context (i.e. MachineKeySet = TRUE), then UserProtected should be FALSE
    Add-Content -Value "UserProtected = $UserProtectedValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    (Get-Content "$CertGenWorking\$CertificateRequestConfigFile" | Foreach-Object {$_ -replace '^MachineKeySet =.+$', "MachineKeySet = $machineKeySet"}) | Set-Content $CertGenWorking\$CertificateRequestConfigFile
}
else {
    if ($UserProtectedValue -ne $null) {
        Add-Content -Value "UserProtected = $UserProtectedValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
    else {
        $UserProtectedValue = "FALSE"
        # If UserProtected = TRUE, the key is protected with a password, and you must enter this password every time the key is accessed
        # If using the certificate under Computer security context (i.e. MachineKeySet = TRUE), then UserProtected should be FALSE
        Add-Content -Value "UserProtected = $UserProtectedValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    }
}

Add-Content -Value 'UseExistingKeySet = FALSE' -Path "$CertGenWorking\$CertificateRequestConfigFile"

if ($ProviderNameOverride -eq "Yes" -or $ProviderNameOverride -eq "y") {
    Write-Host ""
    Write-Host "All available Cryptographic Providers (CSPs) are as follows:"
    Write-Host ""
    $PossibleProvidersPrep = certutil -csplist | Select-String "Provider Name" -Context 0,1
    $PossibleProviders = foreach ($obj1 in $PossibleProvidersPrep) {
        $obj2 = $obj1.Context.PostContext | Select-String 'FAIL' | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Success
        $obj3 = $obj1.Context.PostContext | Select-String 'not ready' | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Success
        if ($obj2 -ne "True" -and $obj3 -ne "True") {
            $obj1.Line -replace "Provider Name: ",""
        }
    }
    $PossibleProviders
    Write-Host ""
    Write-Host "Available Cryptographic Providers (CSPs) based on your choice in Certificate Template (i.e. $($BasisTemplate)) are as follows:"
    Write-Host ""
    $AvailableCSPsBasedOnCertificateTemplate = (Get-ADObject $CertificateTemplateLDAPObject -Properties * | Select-Object -ExpandProperty pkiDefaultCSPs) -replace '[0-9],',''
    $AvailableCSPsBasedOnCertificateTemplate
    $ProviderNameValue = $(Read-Host -Prompt "Please enter the name of the Cryptographic Provider (CSP) you would like to use")
    # Validation check...
    if ($AvailableCSPsBasedOnCertificateTemplate -notcontains $ProviderNameValue) {
        Write-Host "The Provider Name is not valid. Please use one of the values from the list of Available Cryptographic Providers (CSPs) based on your Certificate Template. Halting!"
        exit
    }
    Add-Content -Value "ProviderName = `"$ProviderNameValue`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    
    # Next, get the $ProviderTypeValue based on $ProviderNameValue
    $ProviderTypeValuePrep = certutil -csplist | Select-String $ProviderNameValue -Context 0,1
    $ProviderTypeValue = $ProviderTypePrep.Context.PostContext | Select-String -Pattern '[0-9]{1,2}' | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
    Add-Content -Value "ProviderType = `"$ProviderTypeValue`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
else {
    Add-Content -Value "ProviderName = $ProviderNameValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    $ProviderTypeValuePrep = certutil -csplist | Select-String $ProviderNameValue -Context 0,1
    $ProviderTypeValue = $ProviderTypePrep.Context.PostContext | Select-String -Pattern '[0-9]{1,2}' | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
    Add-Content -Value "ProviderType = `"$ProviderTypeValue`"" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}

if ($RequestTypeOverride -eq "Yes" -or $RequestTypeOverride -eq "y") {
    # TODO: Valid RequestType options are CMC, PKCS10, PKCS10-, PKCS7, and Cert
    # HOWEVER, the "Cert" RequestType indicates a self-signed or self-issued certificate. It does NOT generate a request, but rather a new certificate
    # and then installs the certificate. To create a self-issued certificate that is NOT self-signed, specify a signing cert by using the –cert option 
    # in the certreq.exe command. For this to work, you must 1) add "Cert" to the below $ValidRequestTypes array. 2) Uncomment 
    # the below 'if' statement: if ($RequestTypeValue -eq "Cert"), 3) Uncomment the "certreq -new -cert ..." command, 4) Comment the original 
    # "certreq -new ..." command, and 5) Comment the "certreq submit ..." command
    Write-Host ""
    Write-Host "Available RequestType values are as follows:"
    $ValidRequestTypes = @("CMC", "PKCS10", "PKCS10-", "PKCS7")
    $ValidRequestTypes
    $RequestTypeValue = $(Read-Host -Prompt "Please enter the RequestType value you would like to use")
    # Validation check...
    if ($ValidRequestTypes -notcontains $RequestTypeValue) {
        Write-Host "The RequestType value is not valid. Please choose a RequestType value from the list of available RequestType values. halting!"
        exit
    }
    
    # Add RequestType format  
    Add-Content -Value "RequestType = $RequestTypeValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
else {
    Add-Content -Value "RequestType = $RequestTypeValue" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
<#
TODO: Logic for self-signed and/or self-issued certificates that DO NOT generate a CSR and DO NOT submit to Certificate Authority
if ($RequestTypeValue -eq "Cert") {
    $ValidityPeriodValue = Read-Host -Prompt "Please enter the length of time that the certificate will be valid for.
    #NOTE: Values must be in Months or Years. For example '6 months' or '2 years'"
    $ValidityPeriodPrep = $ValidityPeriodValue.Split(" ") | Select-Object -Index 1
    if ($ValidityPeriodPrep.EndsWith("s")) {
        $ValidityPeriod = $ValidityPeriodPrep.substring(0,1).toupper()+$validityPeriodPrep.substring(1).tolower()
    }
    else {
        $ValidityPeriod = $ValidityPeriodPrep.substring(0,1).toupper()+$validityPeriodPrep.substring(1).tolower()+'s'
    }
    $ValidityPeriodUnits = $ValidityPeriodValue.Split(" ") | Select-Object -Index 0

    Add-Content -Value "ValidityPeriodUnits = $ValidityPeriodUnits" -Path "$CertGenWorking\$CertificateRequestConfigFile"
    Add-Content -Value "ValidityPeriod = $ValidityPeriod" -Path "$CertGenWorking\$CertificateRequestConfigFile"
}
#>

# TODO: Optional additional sections to Certificate Request Config File -
# Add-Content -Value "`n`r" -Path "$CertGenWorking\$CertificateRequestConfigFile"
# Add-Content -Value '[Extensions]' -Path "$CertGenWorking\$CertificateRequestConfigFile"
# Add-Content -Value "Critical=2.5.29.19" -Path "$CertGenWorking\$CertificateRequestConfigFile"

## End Writing Config File ##

##### END Additional Variable Definition and Config File Creation #####


##### BEGIN Generate Certificate Request and Submit to Issuing Certificate Authority #####

## Generate new Certificate Request File: ##
# NOTE: The generation of a Certificate Request File using the below "certreq.exe -new" command also adds the CSR to the 
# Client Machine's Certificate Request Store located at PSDrive "Cert:\CurrentUser\REQUEST" which is also known as 
# "Microsoft.PowerShell.Security\Certificate::CurrentUser\Request"
# There doesn't appear to be an equivalent to this using PowerShell cmdlets
certreq.exe -new "$CertGenWorking\$CertificateRequestConfigFile" "$CertGenWorking\$CertificateRequestFile"
# TODO: If the Certificate Request Configuration File referenced in the above command contains "RequestType = Cert", then instead of the above command, 
# the below certreq command should be used:
# certreq.exe -new -cert [CertId] "$CertGenWorking\$CertificateRequestConfigFile" "$CertGenWorking\$CertificateRequestFile"

Sleep 2

## Submit New Certificate Request File to Issuing Certificate Authority and Specify a Certificate to Use as a Base ##
if (Test-Path "$CertGenWorking\$CertificateRequestFile") {
    certreq.exe -submit -attrib "CertificateTemplate:$cnForBasisTemplate" -config "$IssuingCertAuth" "$CertGenWorking\$CertificateRequestFile" "$CertGenWorking\$CertFileOut" "$CertGenWorking\$CertificateChainOut"
    # Equivalent of above certreq command using "Get-Certificate" cmdlet is below. We decided to use certreq.exe though because it actually outputs
    # files to the filesystem as opposed to just working with the client machine's certificate store.  This is more similar to the same process on Linux.
    #
    # ## Begin "Get-Certificate" equivalent ##
    # $LocationOfCSRInStore = $(Get-ChildItem Cert:\CurrentUser\Request | Where-Object {$_.Subject -like "*$CertificateCN*"}) | Select-Object -ExpandProperty PSPath
    # Get-Certificate -Template $cnForBasisTemplate -Url "https:\\$IssuingCertAuthFQDN\certsrv" -Request $LocationOfCSRInStore -CertStoreLocation Cert:\CurrentUser\My
    # NOTE: The above Get-Certificate command ALSO imports the certificate generated by the above request, making the below "Import-Certificate" command unnecessary
    # ## End "Get-Certificate" equivalent ##
}
if (Test-Path "$CertGenWorking\$CertFileOut") {
    ## Generate .pfx file by installing certificate in store and then exporting with private key ##
    # NOTE: I'm not sure why importing a file that only contains the public certificate (i.e, the .cer file) suddenly makes the private key available
    # in the Certificate Store. It just works for some reason...
    # First, install the public certificate in store
    Import-Certificate -FilePath "$CertGenWorking\$CertFileOut" -CertStoreLocation Cert:\CurrentUser\My
    # certreq.exe equivalent of the above Import-Certificate command is below. It is not as reliable as Import-Certifcate.
    # certreq -accept -user "$CertGenWorking\$CertFileOut"

    # Then, export cert with private key in the form of a .pfx file
    $LocationOfCertInStore = $(Get-ChildItem Cert:\CurrentUser\My | Where-Object {$_.Subject -like "*$CertificateCN*"}) | Select-Object -ExpandProperty PSPath
    Export-PfxCertificate -Cert $LocationOfCertInStore -FilePath "$CertGenWorking\$PFXFileOut" -Password $PFXPwdAsSecureString
    # Equivalent of above using certutil
    # $ThumbprintOfCertToExport = $(Get-ChildItem Cert:\CurrentUser\My | Where-Object {$_.Subject -like "*$CertificateCN*"}) | Select-Object -ExpandProperty Thumbprint
    # certutil -exportPFX -p "$PFXPwdPlainText" my $ThumbprintOfCertToExport "$CertGenWorking\$PFXFileOut"

    if ($UseOpenSSL -eq "Yes" -or $UseOpenSSL -eq "y") {
        if (! (Test-Path $PathToWin32OpenSSL)) {
            $PathToWin32OpenSSL = Read-Host -Prompt "Please enter the path to the Win32 OpenSSL binary directory"
            if (Test-Path $PathToWin32OpenSSL) {
                Write-Host "Path to Win32 OpenSSL directory is valid...Continuing..."
            }
            else {
                Write-Host "Win32 OpenSSL binary directory not found"
                $PathToWin32OpenSSL = Read-Host -Prompt "Please enter the path to the Win32 OpenSSL binary directory"
                if (Test-Path $PathToWin32OpenSSL) {
                    cd $PathToWin32OpenSSL
                }
                else {
                    Write-Host "Win32 OpenSSL binary directory not found. Halting!"
                    exit
                }
            }
            cd $PathToWin32OpenSSL
        }
        else {
            cd $PathToWin32OpenSSL
        }

        # OpenSSL can't handle PowerShell SecureStrings, so need to convert it back into Plain Text
        $PwdForPFXOpenSSL = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($PFXPwdAsSecureString))

        # Extract Private Key and Keep It Password Protected
        openssl pkcs12 -in "$CertGenWorking\$PFXFileOut" -nocerts -out "$CertGenWorking\$ProtectedPrivateKeyOut" -nodes -password pass:$PwdForPFXOpenSSL 2> null

        # The .pfx File Contains ALL Public Certificates in Chain 
        # The below extracts ALL Public Certificates in Chain
        openssl pkcs12 -in "$CertGenWorking\$PFXFileOut" -nokeys -out "$CertGenWorking\$AllPublicKeysInChainOut" -password pass:$PwdForPFXOpenSSL 2> null

        # Extract the Public Certificate specific to the New Certificate that was just made (i.e. NOT the entire chain)
        # This file should have the EXACT SAME CONTENT as the .cer file generated earlier
        $PublicKeySansChainPrep1 = (Get-Content "$CertGenWorking\$AllPublicKeysInChainOut") -join "`n"
        $PublicKeySansChainPrep2 = $PublicKeySansChainPrep1 | Select-String -Pattern '\-----BEGIN CERTIFICATE-----([\s\S]*)\-----END CERTIFICATE-----' | Select-Object -ExpandProperty Matches | Select-Object -ExpandProperty Value
        $PublicKeySansChain = $PublicKeySansChainPrep2.Substring(0, $PublicKeySansChainPrep2.IndexOf('Bag'))
        $PublicKeySansChain | Out-File "$CertGenWorking\$PublicKeySansChainOutFile" -Encoding ascii

        # Determine if we should remove the password from the private key (i.e. $ProtectedPrivateKeyOut)
        if ($StripPrivateKeyOfPassword -eq $null) {
            $StripPrivateKeyOfPassword = Read-Host -Prompt "Would you like to remove password protection from the private key? [Yes/No]"
            if ($StripPrivateKeyOfPassword -eq "Yes" -or $StripPrivateKeyOfPassword -eq "y" -or $StripPrivateKeyOfPassword -eq "No" -or $StripPrivateKeyOfPassword -eq "n") {
                Write-Host "The value for StripPrivateKeyOfPassword is valid...continuing"
            }
            else {
                Write-Host "The value for StripPrivateKeyOfPassword is not valid. Please enter either 'Yes', 'y', 'No', or 'n'."
                $StripPrivateKeyOfPassword = Read-Host -Prompt "Would you like to remove password protection from the private key? [Yes/No]"
                if ($StripPrivateKeyOfPassword -eq "Yes" -or $StripPrivateKeyOfPassword -eq "y" -or $StripPrivateKeyOfPassword -eq "No" -or $StripPrivateKeyOfPassword -eq "n") {
                    Write-Host "The value for StripPrivateKeyOfPassword is valid...continuing"
                }
                else {
                    Write-Host "The value for StripPrivateKeyOfPassword is not valid. Please enter either 'Yes', 'y', 'No', or 'n'. Halting!"
                    exit
                }
            }
            if ($StripPrivateKeyOfPassword -eq "Yes" -or $StripPrivateKeyOfPassword -eq "y") {
                # Strip Private Key of Password
                openssl rsa -in "$CertGenWorking\$ProtectedPrivateKeyOut" -out "$CertGenWorking\$UnProtectedPrivateKeyOut" 2> null
            }
        }
        if ($StripPrivateKeyOfPassword -eq "Yes" -or $StripPrivateKeyOfPassword -eq "y") {
            # Strip Private Key of Password
            openssl rsa -in "$CertGenWorking\$ProtectedPrivateKeyOut" -out "$CertGenWorking\$UnProtectedPrivateKeyOut" 2> null
        }
    }
}


##### END Generate Certificate Request and Submit to Issuing Certificate Authority #####

}

# Generate-Certificate

## Archived Info May Be Useful in Future ##
<#

# The below certutil commands may fail if these certs/chains are already installed as a normal
# result of joining a windows machine to a domain that had certificate services setup properly at the time of joining
# certutil -addstore "Root" "$CertGenWorking\$CertificateChainOut"
# certutil -addstore "CA" "$CertGenWorking\$CertificateChainOut"

#>